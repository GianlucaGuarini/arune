{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://arune/./src/components/global/ sync [a-zA-Z0-9-]+\\.riot","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/dom.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/binding-types.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/dom-bindings/dist/dom-bindings.js","webpack://arune/./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js","webpack://arune/./node_modules/riot/esm/utils/dom.js","webpack://arune/./src/components/global/player/player.riot","webpack://arune/./node_modules/riot/esm/api/__.js","webpack://arune/./node_modules/@riotjs/hot-reload/index.js","webpack://arune/./node_modules/riot/esm/api/component.js","webpack://arune/./node_modules/riot/esm/dependencies/cumpa/index.js","webpack://arune/./src/style.css?e320","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/expression-types.js","webpack://arune/./node_modules/riot/esm/dependencies/bianco.attr/index.next.js","webpack://arune/./node_modules/riot/esm/dependencies/bianco.dom-to-array/index.next.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/misc.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/constants.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/checks.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/objects.js","webpack://arune/./node_modules/riot/esm/core/css-manager.js","webpack://arune/./node_modules/riot/esm/dependencies/bianco.query/index.next.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/strings.js","webpack://arune/./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js","webpack://arune/./node_modules/riot/esm/dependencies/@riotjs/util/functions.js","webpack://arune/./node_modules/riot/esm/core/mocked-template-interface.js","webpack://arune/./node_modules/riot/esm/core/pure-component-api.js","webpack://arune/./node_modules/riot/esm/core/bind-dom-node-to-component-instance.js","webpack://arune/./node_modules/riot/esm/core/create-core-api-methods.js","webpack://arune/./node_modules/riot/esm/core/component-dom-selectors.js","webpack://arune/./node_modules/riot/esm/core/component-lifecycle-methods.js","webpack://arune/./node_modules/riot/esm/dependencies/curri/index.js","webpack://arune/./node_modules/riot/esm/core/compute-component-state.js","webpack://arune/./node_modules/riot/esm/core/compute-initial-props.js","webpack://arune/./node_modules/riot/esm/utils/get-root-computed-attribute-names.js","webpack://arune/./node_modules/riot/esm/core/manage-component-lifecycle.js","webpack://arune/./node_modules/riot/esm/core/run-plugins.js","webpack://arune/./node_modules/riot/esm/core/create-attribute-bindings.js","webpack://arune/./node_modules/riot/esm/core/add-css-hook.js","webpack://arune/./node_modules/riot/esm/core/instantiate-component.js","webpack://arune/./node_modules/riot/esm/core/create-component-from-wrapper.js","webpack://arune/./node_modules/riot/esm/core/component-template-factory.js","webpack://arune/./node_modules/riot/esm/core/create-pure-component.js","webpack://arune/./src/register-global-components.js","webpack://arune/./node_modules/riot/esm/api/register.js","webpack://arune/./node_modules/riot/esm/api/mount.js","webpack://arune/./src/index.js","webpack://arune/./node_modules/riot/esm/core/mount-component.js"],"sourcesContent":["var map = {\n\t\"./player/player.riot\": 258\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 0;","/* Riot WIP, @license MIT */\nimport { dashToCamelCase } from './strings.js';\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method Â¯\\_(ãƒ„)_/Â¯\n */\n\n// Ignore this helper because it's needed only for svg tags\nfunction moveChildren(source, target) {\n  // eslint-disable-next-line fp/no-loops\n  while (source.firstChild) target.appendChild(source.firstChild);\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild);\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nfunction clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0; i < children.length; i++) removeChild(children[i]);\n}\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nconst removeChild = (node) => node.remove();\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nconst insertBefore = (newNode, refNode) =>\n  refNode &&\n  refNode.parentNode &&\n  refNode.parentNode.insertBefore(newNode, refNode);\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nconst replaceChild = (newNode, replaced) =>\n  replaced &&\n  replaced.parentNode &&\n  replaced.parentNode.replaceChild(newNode, replaced);\n\nexport { DOMattributesToObject, cleanNode, clearChildren, insertBefore, moveChildren, removeChild, replaceChild };\n","/* Riot WIP, @license MIT */\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\n\nconst bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT,\n};\n\nexport { EACH, IF, SIMPLE, SLOT, TAG, bindingTypes as default };\n","/* Riot WIP, @license MIT */\nimport { insertBefore, removeChild, cleanNode, clearChildren, moveChildren, replaceChild } from '../../util/dom.js';\nimport { IS_PURE_SYMBOL, PARENT_KEY_SYMBOL } from '../../util/constants.js';\nimport { SIMPLE, SLOT, TAG, EACH, IF } from '../../util/binding-types.js';\nexport { default as bindingTypes } from '../../util/binding-types.js';\nimport { TEXT, EVENT, REF, VALUE, ATTRIBUTE } from '../../util/expression-types.js';\nexport { default as expressionTypes } from '../../util/expression-types.js';\nimport { defineProperty } from '../../util/objects.js';\nimport { isTemplate, isBoolean, isObject, isFunction, isSvg, isNil } from '../../util/checks.js';\nimport { panic, memoize, evaluateAttributeExpressions } from '../../util/misc.js';\n\nconst HEAD_SYMBOL = Symbol();\nconst TAIL_SYMBOL = Symbol();\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n\n  return { head, tail }\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const { head, tail } = createHeadTailPlaceholders();\n\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail],\n  }\n}\n\n/* c8 ignore start */\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nconst udomdiff = (a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node =\n        bEnd < bLength\n          ? bStart\n            ? get(b[bStart - 1], -0).nextSibling\n            : get(b[bEnd - bStart], 0)\n          : before;\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap ðŸ‘)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b\n};\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\n\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const { placeholder, nodes, childrenMap } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n\n    // prepare the diffing\n    const { newChildrenMap, batches, futureNodes } = createPatch(\n      items,\n      scope,\n      parentScope,\n      this,\n    );\n\n    // patch the DOM only if there are new nodes\n    udomdiff(\n      nodes,\n      futureNodes,\n      patch(Array.from(childrenMap.values()), parentScope),\n      placeholder,\n    );\n\n    // trigger the mounts and the updates\n    batches.forEach((fn) => fn());\n\n    // update the children map\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n\n    return this\n  },\n};\n\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const { template, nodes, context } = element;\n        // remove the last node (notice <template> tags might have more children nodes)\n        nodes.pop();\n\n        // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item\n  }\n}\n\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false\n}\n\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\nfunction extendScope(scope, { itemName, indexName, index, item }) {\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n\n  return scope\n}\n\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag,\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item,\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta =\n      isTemplateTag && mustMount\n        ? createTemplateMeta(componentTemplate)\n        : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() =>\n        componentTemplate.mount(el, context, parentScope, meta),\n      );\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    }\n\n    // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    }\n\n    // delete the old item from the children map\n    childrenMap.delete(key);\n    futureNodes.push(...nodes);\n\n    // update the children map\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index,\n    });\n  });\n\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes,\n  }\n}\n\nfunction create$6(\n  node,\n  { evaluate, condition, itemName, indexName, getKey, template },\n) {\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n\n  insertBefore(placeholder, node);\n  removeChild(node);\n\n  return {\n    ...EachBinding,\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder,\n  }\n}\n\n/**\n * Binding responsible for the `if` directive\n */\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break\n      case mustUnmount:\n        this.unmount(scope);\n        break\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n\n    return this\n  },\n};\n\nfunction create$5(node, { evaluate, template }) {\n  const placeholder = document.createTextNode('');\n\n  insertBefore(placeholder, node);\n  removeChild(node);\n\n  return {\n    ...IfBinding,\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node),\n  }\n}\n\n/* c8 ignore next */\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(\n  (name) => ElementProto.hasOwnProperty(name), // eslint-disable-line\n);\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\nfunction setAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach((name) =>\n    attributeExpression({ node, name }, attributes[name]),\n  );\n}\n\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n\n  Object.keys(oldAttributes)\n    .filter((name) => !newKeys.includes(name))\n    .forEach((attribute) => node.removeAttribute(attribute));\n}\n\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\nfunction canRenderAttribute(value) {\n  return ['string', 'number', 'boolean'].includes(typeof value)\n}\n\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @param   {boolean} isBoolean - flag to handle boolean attributes\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\nfunction shouldRemoveAttribute(value, isBoolean) {\n  // boolean attributes should be removed if the value is falsy\n  if (isBoolean) return !value && value !== 0\n  // otherwise we can try to render it\n  return typeof value === 'undefined' || value === null\n}\n\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} expression.node - target node\n * @param   {string} expression.name - attribute name\n * @param   {boolean} expression.isBoolean - flag to handle boolean attributes\n * @param   {*} expression.value - the old expression cached value\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction attributeExpression(\n  { node, name, isBoolean: isBoolean$1, value: oldValue },\n  value,\n) {\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    }\n\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return\n  }\n\n  // store the attribute on the node to make it compatible with native custom elements\n  if (\n    !isNativeHtmlProperty(name) &&\n    (isBoolean(value) || isObject(value) || isFunction(value))\n  ) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value, isBoolean$1)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value, isBoolean$1));\n  }\n}\n\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @param   {boolean} isBoolean - boolean attributes flag\n * @returns {string} input value as string\n */\nfunction normalizeValue(name, value, isBoolean) {\n  // be sure that expressions like selected={ true } will always be rendered as selected='selected'\n  // fix https://github.com/riot/riot/issues/2975\n  return value === true && isBoolean ? name : value\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = (value) =>\n  Array.isArray(value) ? value : [value, false];\n\n// see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  },\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = (node) => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener\n};\n\n/**\n * Set a new event listener\n * @param   {HTMLElement} expression.node - target node\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\nfunction eventExpression({ node, name }, value) {\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\nconst getTextNode = (node, childNodeIndex) => {\n  return node.childNodes[childNodeIndex]\n};\n\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} expression.node - target node\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction textExpression({ node }, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fields value updates\n * @param   {HTMLElement} expression.node - target node\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction valueExpression({ node }, value) {\n  node.value = normalizeStringValue(value);\n}\n\n/**\n   This method handles the REF attribute expressions \n * @param   {HTMLElement} expression.node - target node\n * @param   {*} expression.value - the old expression cached value\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction refExpression({ node, value: oldValue }, value) {\n  // called on mount and update\n  if (value) value(node);\n  // called on unmount\n  // in this case the node value is null\n  else oldValue(null);\n}\n\nconst expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression,\n  [REF]: refExpression,\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n\n  // API methods\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope);\n\n    // IO() DOM updates\n    expressions[this.type](this, this.value);\n\n    return this\n  },\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      expressions[this.type](this, value);\n      this.value = value;\n    }\n\n    return this\n  },\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount event and ref expressions\n    if ([EVENT, REF].includes(this.type)) expressions[this.type](this, null);\n\n    return this\n  },\n};\n\nfunction create$4(node, data) {\n  return {\n    ...Expression,\n    ...data,\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node,\n  }\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return {\n      ...acc,\n      [method]: (scope) => {\n        return collection.map((item) => item[method](scope)) && context\n      },\n    }\n  }, {})\n}\n\nfunction create$3(node, { expressions }) {\n  return flattenCollectionMethods(\n    expressions.map((expression) => create$4(node, expression)),\n    ['mount', 'update', 'unmount'],\n  )\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope\n\n  const expressions = attributes.map((attr) => ({\n    ...attr,\n    value: attr.evaluate(scope),\n  }));\n\n  return Object.assign(\n    Object.create(parentScope || null),\n    evaluateAttributeExpressions(expressions),\n  )\n}\n\n// this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\nconst getRealParent = (scope, parentScope) =>\n  scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n  // templateData: null,\n  // template: null,\n\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope)\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots\n      ? scope.slots.find(({ id }) => id === this.name)\n      : false;\n    const { parentNode } = this.node;\n\n    // if the slot did not pass any content, we will use the self slot for optional fallback content (https://github.com/riot/riot/issues/3024)\n    const realParent = templateData ? getRealParent(scope, parentScope) : scope;\n\n    this.templateData = templateData;\n\n    // override the template property if the slot needs to be replaced\n    this.template =\n      (templateData &&\n        create(templateData.html, templateData.bindings).createDOM(\n          parentNode,\n        )) ||\n      // otherwise use the optional template fallback if provided by the compiler see also https://github.com/riot/riot/issues/3014\n      this.template?.clone();\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(\n        this.node,\n        this.getTemplateScope(scope, realParent),\n        realParent,\n      );\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n\n    return this\n  },\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = this.templateData\n        ? getRealParent(scope, parentScope)\n        : scope;\n\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(\n        this.getTemplateScope(scope, parentScope),\n        null,\n        mustRemoveRoot,\n      );\n    }\n\n    return this\n  },\n};\n\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method Â¯\\_(ãƒ„)_/Â¯\n */\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n\n  if (!child) return\n\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\nfunction createSlot(node, { name, attributes, template }) {\n  return {\n    ...SlotBinding,\n    attributes,\n    template,\n    node,\n    name,\n  }\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\nfunction getTag(component, slots = [], attributes = []) {\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({ slots, attributes })\n  }\n\n  // otherwise we return a template chunk\n  return create(slotsToMarkup(slots), [\n    ...slotBindings(slots),\n    {\n      // the attributes should be registered as binding\n      // if we fallback to a normal template chunk\n      expressions: attributes.map((attr) => {\n        return {\n          type: ATTRIBUTE,\n          ...attr,\n        }\n      }),\n    },\n  ])\n}\n\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\nfunction slotBindings(slots) {\n  return slots.reduce((acc, { bindings }) => acc.concat(bindings), [])\n}\n\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html\n  }, '')\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n\n  mount(scope) {\n    return this.update(scope)\n  },\n  update(scope, parentScope) {\n    const name = this.evaluate(scope);\n\n    // simple update\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true);\n\n      // mount the new tag\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this\n  },\n};\n\nfunction create$2(\n  node,\n  { evaluate, getComponent, slots, attributes },\n) {\n  return {\n    ...TagBinding,\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent,\n  }\n}\n\nconst bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot,\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map((e) =>\n    e.type === TEXT\n      ? {\n          ...e,\n          childNodeIndex: e.childNodeIndex + textExpressionsOffset,\n        }\n      : e,\n  )\n}\n\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\nfunction create$1(root, binding, templateTagOffset) {\n  const { selector, type, redundantAttribute, expressions } = binding;\n  // find the node to apply the bindings\n  const node = selector ? root.querySelector(selector) : root;\n\n  // remove eventually additional attributes created only to select this node\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || [];\n\n  // init the binding\n  return (bindings[type] || bindings[SIMPLE])(node, {\n    ...binding,\n    expressions:\n      templateTagOffset && !selector\n        ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset)\n        : bindingExpressions,\n  })\n}\n\n// in this case a simple innerHTML is enough\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content\n}\n\n// for svg nodes we need a bit more work\n/* c8 ignore start */\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(\n    new window.DOMParser().parseFromString(\n      `<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`,\n      'application/xml',\n    ).documentElement,\n    true,\n  );\n\n  return svgNode\n}\n/* c8 ignore end */\n\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\nfunction createDOMTree(root, html) {\n  /* c8 ignore next */\n  if (isSvg(root)) return createSVGTree(html, root)\n\n  return createHTMLTree(html, root)\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html)\n}\n\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0)\n}\n\n/**\n * Template Chunk model\n * @type {Object}\n */\nconst TemplateChunk = {\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom =\n      this.dom ||\n      createTemplateDOM(el, this.html) ||\n      document.createDocumentFragment();\n\n    return this\n  },\n\n  // API methods\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta = {}) {\n    if (!el) panic('Please provide DOM node to mount properly your template');\n\n    if (this.el) this.unmount(scope);\n\n    // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n    const { fragment, children, avoidDOMInjection } = meta;\n    // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n    const { parentNode } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag\n      ? getTemplateTagOffset(parentNode, el, meta)\n      : null;\n\n    // create the DOM if it wasn't created before\n    this.createDOM(el);\n\n    // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n    const cloneNode = fragment || this.dom.cloneNode(true);\n\n    // store root node\n    // notice that for template tags the root note will be the parent tag\n    this.el = isTemplateTag ? parentNode : el;\n\n    // create the children array only for the <template> fragments\n    this.children = isTemplateTag\n      ? children || Array.from(cloneNode.childNodes)\n      : null;\n\n    // inject the DOM into the el only if a fragment is available\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode);\n\n    // create the bindings\n    this.bindings = this.bindingsData.map((binding) =>\n      create$1(this.el, binding, templateTagOffset),\n    );\n    this.bindings.forEach((b) => b.mount(scope, parentScope));\n\n    // store the template meta properties\n    this.meta = meta;\n\n    return this\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach((b) => b.update(scope, parentScope));\n\n    return this\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot = false) {\n    const el = this.el;\n\n    if (!el) {\n      return this\n    }\n\n    this.bindings.forEach((b) => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break\n\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break\n\n      // clean the node children only\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break\n\n      // remove the root node only if the mustRemoveRoot is truly\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break\n    }\n\n    this.el = null;\n\n    return this\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return {\n      ...this,\n      meta: {},\n      el: null,\n    }\n  },\n};\n\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\nfunction create(html, bindings = []) {\n  return {\n    ...TemplateChunk,\n    html,\n    bindingsData: bindings,\n  }\n}\n\nexport { create$1 as createBinding, create$4 as createExpression, create as template };\n","\"use strict\";\n\n/* eslint-env browser */\n/*\n  eslint-disable\n  no-console,\n  func-names\n*/\n\n/** @typedef {any} TODO */\n\nvar normalizeUrl = require(\"./normalize-url\");\nvar srcByModuleId = Object.create(null);\nvar noDocument = typeof document === \"undefined\";\nvar forEach = Array.prototype.forEach;\n\n/**\n * @param {function} fn\n * @param {number} time\n * @returns {(function(): void)|*}\n */\nfunction debounce(fn, time) {\n  var timeout = 0;\n  return function () {\n    // @ts-ignore\n    var self = this;\n    // eslint-disable-next-line prefer-rest-params\n    var args = arguments;\n    var functionCall = function functionCall() {\n      return fn.apply(self, args);\n    };\n    clearTimeout(timeout);\n\n    // @ts-ignore\n    timeout = setTimeout(functionCall, time);\n  };\n}\nfunction noop() {}\n\n/**\n * @param {TODO} moduleId\n * @returns {TODO}\n */\nfunction getCurrentScriptUrl(moduleId) {\n  var src = srcByModuleId[moduleId];\n  if (!src) {\n    if (document.currentScript) {\n      src = ( /** @type {HTMLScriptElement} */document.currentScript).src;\n    } else {\n      var scripts = document.getElementsByTagName(\"script\");\n      var lastScriptTag = scripts[scripts.length - 1];\n      if (lastScriptTag) {\n        src = lastScriptTag.src;\n      }\n    }\n    srcByModuleId[moduleId] = src;\n  }\n\n  /**\n   * @param {string} fileMap\n   * @returns {null | string[]}\n   */\n  return function (fileMap) {\n    if (!src) {\n      return null;\n    }\n    var splitResult = src.split(/([^\\\\/]+)\\.js$/);\n    var filename = splitResult && splitResult[1];\n    if (!filename) {\n      return [src.replace(\".js\", \".css\")];\n    }\n    if (!fileMap) {\n      return [src.replace(\".js\", \".css\")];\n    }\n    return fileMap.split(\",\").map(function (mapRule) {\n      var reg = new RegExp(\"\".concat(filename, \"\\\\.js$\"), \"g\");\n      return normalizeUrl(src.replace(reg, \"\".concat(mapRule.replace(/{fileName}/g, filename), \".css\")));\n    });\n  };\n}\n\n/**\n * @param {TODO} el\n * @param {string} [url]\n */\nfunction updateCss(el, url) {\n  if (!url) {\n    if (!el.href) {\n      return;\n    }\n\n    // eslint-disable-next-line\n    url = el.href.split(\"?\")[0];\n  }\n  if (!isUrlRequest( /** @type {string} */url)) {\n    return;\n  }\n  if (el.isLoaded === false) {\n    // We seem to be about to replace a css link that hasn't loaded yet.\n    // We're probably changing the same file more than once.\n    return;\n  }\n  if (!url || !(url.indexOf(\".css\") > -1)) {\n    return;\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  el.visited = true;\n  var newEl = el.cloneNode();\n  newEl.isLoaded = false;\n  newEl.addEventListener(\"load\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.addEventListener(\"error\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.href = \"\".concat(url, \"?\").concat(Date.now());\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(newEl, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(newEl);\n  }\n}\n\n/**\n * @param {string} href\n * @param {TODO} src\n * @returns {TODO}\n */\nfunction getReloadUrl(href, src) {\n  var ret;\n\n  // eslint-disable-next-line no-param-reassign\n  href = normalizeUrl(href);\n  src.some(\n  /**\n   * @param {string} url\n   */\n  // eslint-disable-next-line array-callback-return\n  function (url) {\n    if (href.indexOf(src) > -1) {\n      ret = url;\n    }\n  });\n  return ret;\n}\n\n/**\n * @param {string} [src]\n * @returns {boolean}\n */\nfunction reloadStyle(src) {\n  if (!src) {\n    return false;\n  }\n  var elements = document.querySelectorAll(\"link\");\n  var loaded = false;\n  forEach.call(elements, function (el) {\n    if (!el.href) {\n      return;\n    }\n    var url = getReloadUrl(el.href, src);\n    if (!isUrlRequest(url)) {\n      return;\n    }\n    if (el.visited === true) {\n      return;\n    }\n    if (url) {\n      updateCss(el, url);\n      loaded = true;\n    }\n  });\n  return loaded;\n}\nfunction reloadAll() {\n  var elements = document.querySelectorAll(\"link\");\n  forEach.call(elements, function (el) {\n    if (el.visited === true) {\n      return;\n    }\n    updateCss(el);\n  });\n}\n\n/**\n * @param {string} url\n * @returns {boolean}\n */\nfunction isUrlRequest(url) {\n  // An URL is not an request if\n\n  // It is not http or https\n  if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(url)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {TODO} moduleId\n * @param {TODO} options\n * @returns {TODO}\n */\nmodule.exports = function (moduleId, options) {\n  if (noDocument) {\n    console.log(\"no window.document found, will not HMR CSS\");\n    return noop;\n  }\n  var getScriptSrc = getCurrentScriptUrl(moduleId);\n  function update() {\n    var src = getScriptSrc(options.filename);\n    var reloaded = reloadStyle(src);\n    if (options.locals) {\n      console.log(\"[HMR] Detected local css modules. Reload all css\");\n      reloadAll();\n      return;\n    }\n    if (reloaded) {\n      console.log(\"[HMR] css reload %s\", src.join(\" \"));\n    } else {\n      console.log(\"[HMR] Reload all css\");\n      reloadAll();\n    }\n  }\n  return debounce(update, 50);\n};","/* Riot v9.4.6, @license MIT */\nimport { IS_DIRECTIVE } from '../dependencies/@riotjs/util/constants.js';\nimport { get } from '../dependencies/bianco.attr/index.next.js';\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase()\n}\n\nexport { getName };\n","<player>\n  <audio src=\"https://media.githubusercontent.com/media/GianlucaGuarini/arune/main/src/assets/audio/fx.mp3\" loop/>\n  <button class={state.isPlaying ? 'playing' : ''} onclick={toggleAudio} title={getButtonTitle()}>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 48 48\" preserveAspectRatio=\"xMidYMid meet\">\n      <path if={!state.isPlaying} d=\"M16 37.85v-28l22 14Zm3-14Zm0 8.55 13.45-8.55L19 15.3Z\"/>\n      <path if={state.isPlaying} d=\"M28.25 38V10H36v28ZM12 38V10h7.75v28Z\"/>\n    </svg>\n  </button>\n\n  <script>\n    export default {\n      state: {\n        isPlaying: false\n      },\n      onMounted() {\n        this.player = this.$('audio')\n      },\n      onUpdated() {\n        if (this.state.isPlaying && !this.player.playing) {\n          this.player.play()\n        } else if (!this.player.playing) {\n          this.player.pause()\n        }\n      },\n      getButtonTitle() {\n        return this.state.isPlaying ? 'Stop this madness' : 'Give me some vibes'\n      },\n      toggleAudio() {\n        this.update({\n          isPlaying: !this.state.isPlaying\n        })\n      }\n    }\n  </script>\n\n  <style>\n    :host {\n      position: fixed;\n      bottom: 16px;\n      right: 16px;\n    }\n\n    button {\n      position: relative;\n      padding: 0;\n      cursor: pointer;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      background: transparent;\n      color: var(--text-color);\n      border: 2px solid var(--text-color);\n      width: 32px;\n      height: 32px;\n      border-radius: 100%;\n    }\n\n    button:hover, button:focus {\n      color: var(--active-color);\n      border-color: var(--active-color);\n    }\n\n    button::before, button::after {\n      content: '';\n      position: absolute;\n      top: -2px;\n      left: -2px;\n      visibility: hidden;\n      display: block;\n      width: 32px;\n      height: 32px;\n      border-radius: 100%;\n      z-index: -1;\n    }\n\n    button::before {\n      background: rgba(255, 255, 255, 0.4);\n    }\n\n    button::after {\n      background: rgba(255, 255, 255, 0.2);\n    }\n\n    button.playing::before, button.playing::after {\n      visibility: visible;\n    }\n\n    button.playing::before {\n      animation: buttonAnimation1 ease-in-out 300ms alternate infinite;\n    }\n\n    button.playing::after {\n      animation: buttonAnimation2 ease-in-out 500ms alternate infinite;\n    }\n\n    svg {\n      width: 28px;\n      height: 28px;\n      border-radius: 100%;\n      background: var(--background-color);\n    }\n\n    @keyframes buttonAnimation1 {\n      from {\n        transform: scale(1)\n      }\n      to {\n        transform: scale(1.2)\n      }\n    }\n\n    @keyframes buttonAnimation2 {\n      from {\n        transform: scale(1)\n      }\n      to {\n        transform: scale(1.3)\n      }\n    }\n  </style>\n</player>\n","/* Riot v9.4.6, @license MIT */\nimport bindingTypes from '../dependencies/@riotjs/util/binding-types.js';\nimport { PARENT_KEY_SYMBOL, DOM_COMPONENT_INSTANCE_PROPERTY, PLUGINS_SET, COMPONENTS_IMPLEMENTATION_MAP, ATTRIBUTES_KEY_SYMBOL, IS_COMPONENT_UPDATING, STATE_KEY, PROPS_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport expressionTypes from '../dependencies/@riotjs/util/expression-types.js';\nimport { createExpression as create$4, createBinding as create$1, template as create } from '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\nimport cssManager from '../core/css-manager.js';\n\n// expose some internal stuff that might be used from external tools\nconst __ = {\n  cssManager,\n  DOMBindings: {\n    template: create,\n    createBinding: create$1,\n    createExpression: create$4,\n    bindingTypes,\n    expressionTypes,\n  },\n  globals: {\n    PROPS_KEY,\n    STATE_KEY,\n    IS_COMPONENT_UPDATING,\n    ATTRIBUTES_KEY_SYMBOL,\n    COMPONENTS_IMPLEMENTATION_MAP,\n    PLUGINS_SET,\n    DOM_COMPONENT_INSTANCE_PROPERTY,\n    PARENT_KEY_SYMBOL,\n  },\n};\n\nexport { __ };\n","import { __, component } from 'riot';\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n\nconst { cssManager } = __;\nconst { DOM_COMPONENT_INSTANCE_PROPERTY } = __.globals;\n\nfunction reload(componentAPI) {\n  const { name } = componentAPI;\n\n  if (!name) {\n    console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n    return []\n  }\n\n  return $(`${name}, [is=${name}]`).map((el) => {\n    const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n    // early return in case there is no riot instance found\n    if (!oldTag) return\n\n    // remove the tag template from the DOM\n    oldTag.unmount(true);\n    // delete the old css from the css manager\n    cssManager.remove(name);\n\n    // create the new tag\n    const newTag = component(componentAPI)(el, oldTag.props);\n    newTag.update(oldTag.state);\n\n    return newTag\n  })\n}\n\nexport { reload as default };\n","/* Riot v9.4.6, @license MIT */\nimport compose from '../dependencies/cumpa/index.js';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\nfunction component(implementation) {\n  return (el, props, { slots, attributes, parentScope } = {}) =>\n    compose(\n      (c) => c.mount(el, parentScope),\n      (c) => c({ props, slots, attributes }),\n      createComponentFromWrapper,\n    )(implementation)\n}\n\nexport { component };\n","/* Riot WIP, @license MIT */\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nfunction compose(...fns) {\n  return fns.reduce((f, g) => (...args) => f(g(...args)))\n}\n\nexport { compose as default };\n","// extracted by mini-css-extract-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1743364423290\n        var cssReload = require(\"../node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","/* Riot WIP, @license MIT */\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nconst REF = 4;\n\nconst expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE,\n  REF,\n};\n\nexport { ATTRIBUTE, EVENT, REF, TEXT, VALUE, expressionTypes as default };\n","/* Riot WIP, @license MIT */\nimport domToArray from '../bianco.dom-to-array/index.next.js';\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values;\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)))\n  }))\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : { [name]: value };\n  const props = Object.keys(attrs);\n\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute')\n}\n\nexport { get, set };\n","/* Riot WIP, @license MIT */\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}\n\nexport { domToArray as default };\n","/* Riot WIP, @license MIT */\nimport { VALUE, ATTRIBUTE } from './expression-types.js';\nimport { dashToCamelCase } from './strings.js';\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @param   { string } cause - optional error cause object\n * @returns { undefined } hoppla... at this point the program should stop working\n */\nfunction panic(message, cause) {\n  throw new Error(message, { cause })\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nfunction memoize(fn) {\n  const cache = new Map();\n  const cached = (val) => {\n    return cache.has(val)\n      ? cache.get(val)\n      : cache.set(val, fn.call(this, val)) && cache.get(val)\n  };\n  cached.cache = cache;\n  return cached\n}\n\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const { value, type } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return {\n          ...acc,\n          ...value,\n        }\n      // value attribute\n      case type === VALUE:\n        acc.value = attribute.value;\n        break\n      // normal attributes\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc\n  }, {})\n}\n\nexport { evaluateAttributeExpressions, memoize, panic };\n","/* Riot WIP, @license MIT */\n// Riot.js constants that can be used across more modules\n\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nexport { ATTRIBUTES_KEY_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP, DOM_COMPONENT_INSTANCE_PROPERTY, IS_COMPONENT_UPDATING, IS_DIRECTIVE, IS_PURE_SYMBOL, MOUNT_METHOD_KEY, ON_BEFORE_MOUNT_KEY, ON_BEFORE_UNMOUNT_KEY, ON_BEFORE_UPDATE_KEY, ON_MOUNTED_KEY, ON_UNMOUNTED_KEY, ON_UPDATED_KEY, PARENT_KEY_SYMBOL, PLUGINS_SET, PROPS_KEY, ROOT_KEY, SHOULD_UPDATE_KEY, SLOTS_KEY, STATE_KEY, TEMPLATE_KEY_SYMBOL, UNMOUNT_METHOD_KEY, UPDATE_METHOD_KEY };\n","/* Riot WIP, @license MIT */\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n\n  return !!owner || owner === null\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nfunction isFunction(value) {\n  return checkType(value, 'function')\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nfunction isBoolean(value) {\n  return checkType(value, 'boolean')\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nfunction isNil(value) {\n  return value === null || value === undefined\n}\n\n/**\n * Detect node js environment\n * @returns {boolean} true if the runtime is node\n */\nfunction isNode() {\n  return typeof globalThis.process !== 'undefined'\n}\n\nexport { checkType, isBoolean, isFunction, isNil, isNode, isObject, isSvg, isTemplate };\n","/* Riot WIP, @license MIT */\nimport { isObject } from './checks.js';\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options = {}) {\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, {\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    ...options,\n  });\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} the original object modified\n */\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(([key, value]) => {\n    defineProperty(source, key, value, options);\n  });\n\n  return source\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(([key, value]) => {\n    if (!source[key]) source[key] = value;\n  });\n\n  return source\n}\n\n/**\n * Generate a new object picking only the properties from a given array\n * @param {Object} source - target object\n * @param {Array} keys - list of keys that we want to copy over to the new object\n * @return {Object} a new object conaining only the keys that we have picked from the keys array list\n */\nfunction pick(source, keys) {\n  return isObject(source)\n    ? Object.fromEntries(keys.map((key) => [key, source[key]]))\n    : source\n}\n\nexport { defineDefaults, defineProperties, defineProperty, pick };\n","/* Riot v9.4.6, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\nimport { set } from '../dependencies/bianco.attr/index.next.js';\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]';\n\n// memoized curried function\nconst getStyleNode = ((style) => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style\n\n    // create a new style element or use an existing one\n    // and cache it internally\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n\n    /* istanbul ignore next */\n    if (!style.parentNode) document.head.appendChild(style);\n\n    return style\n  }\n})();\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nconst cssManager = {\n  CSS_BY_NAME,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this\n  },\n};\n\nexport { CSS_BY_NAME, STYLE_NODE_SELECTOR, cssManager as default };\n","/* Riot WIP, @license MIT */\nimport domToArray from '../bianco.dom-to-array/index.next.js';\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n\nexport { $ as default };\n","/* Riot WIP, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}\n\nexport { camelToDashCase, dashToCamelCase };\n","\"use strict\";\n\n/* eslint-disable */\n\n/**\n * @param {string[]} pathComponents\n * @returns {string}\n */\nfunction normalizeUrl(pathComponents) {\n  return pathComponents.reduce(function (accumulator, item) {\n    switch (item) {\n      case \"..\":\n        accumulator.pop();\n        break;\n      case \".\":\n        break;\n      default:\n        accumulator.push(item);\n    }\n    return accumulator;\n  }, /** @type {string[]} */[]).join(\"/\");\n}\n\n/**\n * @param {string} urlString\n * @returns {string}\n */\nmodule.exports = function (urlString) {\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return urlString;\n  }\n  var protocol = urlString.indexOf(\"//\") !== -1 ? urlString.split(\"//\")[0] + \"//\" : \"\";\n  var components = urlString.replace(new RegExp(protocol, \"i\"), \"\").split(\"/\");\n  var host = components[0].toLowerCase().replace(/\\.$/, \"\");\n  components[0] = \"\";\n  var path = normalizeUrl(components);\n  return protocol + host + path;\n};","/* Riot WIP, @license MIT */\nimport { isFunction } from './checks.js';\n\n// does simply nothing\nfunction noop() {\n  return this\n}\n\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\nfunction autobindMethods(source, methods) {\n  methods.forEach((method) => {\n    source[method] = source[method].bind(source);\n  });\n\n  return source\n}\n\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\nfunction callOrAssign(source) {\n  return isFunction(source)\n    ? source.prototype && source.prototype.constructor\n      ? new source()\n      : source()\n    : source\n}\n\nexport { autobindMethods, callOrAssign, noop };\n","/* Riot v9.4.6, @license MIT */\nimport { UNMOUNT_METHOD_KEY, UPDATE_METHOD_KEY, MOUNT_METHOD_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { removeChild, cleanNode } from '../dependencies/@riotjs/util/dom.js';\nimport { noop } from '../dependencies/@riotjs/util/functions.js';\n\n// Components without template use a mocked template interface with some basic functionalities to\n// guarantee consistent rendering behaviour see https://github.com/riot/riot/issues/2984\nconst MOCKED_TEMPLATE_INTERFACE = {\n  [MOUNT_METHOD_KEY](el) {\n    this.el = el;\n  },\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY](_, __, mustRemoveRoot = false) {\n    if (mustRemoveRoot) removeChild(this.el);\n    else if (!mustRemoveRoot) cleanNode(this.el);\n  },\n  clone() {\n    return { ...this }\n  },\n  createDOM: noop,\n};\n\nexport { MOCKED_TEMPLATE_INTERFACE };\n","/* Riot v9.4.6, @license MIT */\nimport { UNMOUNT_METHOD_KEY, UPDATE_METHOD_KEY, MOUNT_METHOD_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { noop } from '../dependencies/@riotjs/util/functions.js';\n\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop,\n});\n\nexport { PURE_COMPONENT_API };\n","/* Riot v9.4.6, @license MIT */\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\nconst bindDOMNodeToComponentInstance = (node, component) =>\n  (node[DOM_COMPONENT_INSTANCE_PROPERTY] = component);\n\nexport { bindDOMNodeToComponentInstance };\n","/* Riot v9.4.6, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce(\n    (acc, method) => {\n      acc[method] = mapFunction(method);\n\n      return acc\n    },\n    {},\n  )\n}\n\nexport { createCoreAPIMethods };\n","/* Riot v9.4.6, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\n\nconst COMPONENT_DOM_SELECTORS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0]\n  },\n  $$(selector) {\n    return $(selector, this.root)\n  },\n});\n\nexport { COMPONENT_DOM_SELECTORS };\n","/* Riot v9.4.6, @license MIT */\nimport { ON_UNMOUNTED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UPDATED_KEY, ON_BEFORE_UPDATE_KEY, ON_MOUNTED_KEY, ON_BEFORE_MOUNT_KEY, SHOULD_UPDATE_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { noop } from '../dependencies/@riotjs/util/functions.js';\n\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop,\n});\n\nexport { COMPONENT_LIFECYCLE_METHODS };\n","/* Riot WIP, @license MIT */\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn, ...acc) {\n  return (...args) => {\n    args = [...acc, ...args];\n\n    return args.length < fn.length ?\n      curry(fn, ...args) :\n      fn(...args)\n  }\n}\n\nexport { curry as default };\n","/* Riot v9.4.6, @license MIT */\nimport { callOrAssign } from '../dependencies/@riotjs/util/functions.js';\n\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state given to the `update` call\n * @returns {Object} new object state\n */\nfunction computeComponentState(oldState, newState) {\n  return {\n    ...oldState,\n    ...callOrAssign(newState),\n  }\n}\n\nexport { computeComponentState };\n","/* Riot v9.4.6, @license MIT */\nimport { DOMattributesToObject } from '../dependencies/@riotjs/util/dom.js';\nimport { callOrAssign } from '../dependencies/@riotjs/util/functions.js';\n\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\nfunction computeInitialProps(element, initialProps = {}) {\n  return {\n    ...DOMattributesToObject(element),\n    ...callOrAssign(initialProps),\n  }\n}\n\nexport { computeInitialProps };\n","/* Riot v9.4.6, @license MIT */\nimport '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\nimport expressionTypes from '../dependencies/@riotjs/util/expression-types.js';\nimport { memoize } from '../dependencies/@riotjs/util/misc.js';\n\n/**\n * Get the computed attribute names from the template instance\n * Since these attributes will not change we memoize the result of this computation\n * @param {TemplateChunk} template - template instance\n * @return {[]} list of attribute names that will be computed by the template expressions\n */\nconst getRootComputedAttributeNames = memoize((template) => {\n  const firstBinding = template?.bindingsData?.[0];\n\n  // if the first binding has the selector attribute it means that it doesn't belong to the root node\n  if (firstBinding?.selector) return []\n\n  return (\n    firstBinding?.expressions?.reduce(\n      (acc, { name, type }) =>\n        type === expressionTypes.ATTRIBUTE ? acc.concat([name]) : acc,\n      [],\n    ) ?? []\n  )\n});\n\nexport { getRootComputedAttributeNames };\n","/* Riot v9.4.6, @license MIT */\nimport { isFunction, isObject } from '../dependencies/@riotjs/util/checks.js';\nimport { ON_BEFORE_UNMOUNT_KEY, PROPS_KEY, STATE_KEY, ATTRIBUTES_KEY_SYMBOL, TEMPLATE_KEY_SYMBOL, PARENT_KEY_SYMBOL, ON_UNMOUNTED_KEY, ROOT_KEY, SHOULD_UPDATE_KEY, ON_BEFORE_UPDATE_KEY, IS_COMPONENT_UPDATING, ON_UPDATED_KEY, IS_PURE_SYMBOL, SLOTS_KEY, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, IS_DIRECTIVE } from '../dependencies/@riotjs/util/constants.js';\nimport { DOMattributesToObject } from '../dependencies/@riotjs/util/dom.js';\nimport { autobindMethods } from '../dependencies/@riotjs/util/functions.js';\nimport { evaluateAttributeExpressions } from '../dependencies/@riotjs/util/misc.js';\nimport { defineProperties, defineProperty, pick } from '../dependencies/@riotjs/util/objects.js';\nimport { addCssHook } from './add-css-hook.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { computeComponentState } from './compute-component-state.js';\nimport { computeInitialProps } from './compute-initial-props.js';\nimport { createAttributeBindings } from './create-attribute-bindings.js';\nimport { runPlugins } from './run-plugins.js';\nimport { getRootComputedAttributeNames } from '../utils/get-root-computed-attribute-names.js';\n\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\nfunction manageComponentLifecycle(\n  component,\n  { slots, attributes, props },\n) {\n  return autobindMethods(\n    runPlugins(\n      defineProperties(\n        isObject(component) ? Object.create(component) : component,\n        {\n          mount(element, state = {}, parentScope) {\n            // any element mounted passing through this function can't be a pure component\n            defineProperty(element, IS_PURE_SYMBOL, false);\n            this[PARENT_KEY_SYMBOL] = parentScope;\n            this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(\n              element,\n              attributes,\n            ).mount(parentScope);\n\n            defineProperty(\n              this,\n              PROPS_KEY,\n              Object.freeze({\n                ...computeInitialProps(element, props),\n                ...evaluateAttributeExpressions(\n                  this[ATTRIBUTES_KEY_SYMBOL].expressions,\n                ),\n              }),\n            );\n\n            this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n            this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();\n\n            // link this object to the DOM node\n            bindDOMNodeToComponentInstance(element, this);\n            // add eventually the 'is' attribute\n            component.name && addCssHook(element, component.name);\n\n            // define the root element\n            defineProperty(this, ROOT_KEY, element);\n            // define the slots array\n            defineProperty(this, SLOTS_KEY, slots);\n\n            // before mount lifecycle event\n            this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n            // mount the template\n            this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n            this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n            return this\n          },\n          update(state = {}, parentScope) {\n            if (parentScope) {\n              this[PARENT_KEY_SYMBOL] = parentScope;\n              this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n            }\n\n            // get the attribute names that don't belong to the the props object\n            // this will avoid recursive props rendering https://github.com/riot/riot/issues/2994\n            const computedAttributeNames = getRootComputedAttributeNames(\n              this[TEMPLATE_KEY_SYMBOL],\n            );\n            // filter out the computed attributes from the root node\n            const staticRootAttributes = Array.from(\n              this[ROOT_KEY].attributes,\n            ).filter(({ name }) => !computedAttributeNames.includes(name));\n\n            // evaluate the value of the static dom attributes\n            const domNodeAttributes = DOMattributesToObject({\n              attributes: staticRootAttributes,\n            });\n\n            // Avoid adding the riot \"is\" directives to the component props\n            // eslint-disable-next-line no-unused-vars\n            const { [IS_DIRECTIVE]: _, ...newProps } = {\n              ...domNodeAttributes,\n              ...evaluateAttributeExpressions(\n                this[ATTRIBUTES_KEY_SYMBOL].expressions,\n              ),\n            };\n            if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false)\n              return\n\n            defineProperty(\n              this,\n              PROPS_KEY,\n              Object.freeze({\n                // only root components will merge their initial props with the new ones\n                // children components will just get them overridden see also https://github.com/riot/riot/issues/2978\n                ...(parentScope\n                  ? pick(this[PROPS_KEY], computedAttributeNames)\n                  : this[PROPS_KEY]),\n                ...newProps,\n              }),\n            );\n\n            this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n\n            this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n            // avoiding recursive updates\n            // see also https://github.com/riot/riot/issues/2895\n            if (!this[IS_COMPONENT_UPDATING]) {\n              this[IS_COMPONENT_UPDATING] = true;\n              this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n            }\n\n            this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n            this[IS_COMPONENT_UPDATING] = false;\n\n            return this\n          },\n          unmount(preserveRoot) {\n            this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n            this[ATTRIBUTES_KEY_SYMBOL].unmount();\n            // if the preserveRoot is null the template html will be left untouched\n            // in that case the DOM cleanup will happen differently from a parent node\n            this[TEMPLATE_KEY_SYMBOL].unmount(\n              this,\n              this[PARENT_KEY_SYMBOL],\n              preserveRoot === null ? null : !preserveRoot,\n            );\n            this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n            return this\n          },\n        },\n      ),\n    ),\n    Object.keys(component).filter((prop) => isFunction(component[prop])),\n  )\n}\n\nexport { manageComponentLifecycle };\n","/* Riot v9.4.6, @license MIT */\nimport { PLUGINS_SET } from '../dependencies/@riotjs/util/constants.js';\n\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component)\n}\n\nexport { runPlugins };\n","/* Riot v9.4.6, @license MIT */\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\nimport { createExpression as create$4 } from '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\n\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\nfunction createAttributeBindings(node, attributes = []) {\n  const expressions = attributes.map((a) => create$4(node, a));\n  const binding = {};\n\n  return Object.assign(binding, {\n    expressions,\n    ...createCoreAPIMethods((method) => (scope) => {\n      expressions.forEach((e) => e[method](scope));\n\n      return binding\n    }),\n  })\n}\n\nexport { createAttributeBindings };\n","/* Riot v9.4.6, @license MIT */\nimport { IS_DIRECTIVE } from '../dependencies/@riotjs/util/constants.js';\nimport { getName } from '../utils/dom.js';\nimport { set } from '../dependencies/bianco.attr/index.next.js';\n\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n\nexport { addCssHook };\n","/* Riot v9.4.6, @license MIT */\nimport { ROOT_KEY, SLOTS_KEY, STATE_KEY, PROPS_KEY } from '../dependencies/@riotjs/util/constants.js';\nimport { defineProperties, defineDefaults } from '../dependencies/@riotjs/util/objects.js';\nimport { COMPONENT_DOM_SELECTORS } from './component-dom-selectors.js';\nimport { COMPONENT_LIFECYCLE_METHODS } from './component-lifecycle-methods.js';\nimport cssManager from './css-manager.js';\nimport curry from '../dependencies/curri/index.js';\nimport { manageComponentLifecycle } from './manage-component-lifecycle.js';\n\n/**\n * Component definition function\n * @param   {Object} implementation - the component implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\nfunction instantiateComponent({ css, template, componentAPI, name }) {\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n\n  return curry(manageComponentLifecycle)(\n    defineProperties(\n      // set the component defaults without overriding the original component API\n      defineDefaults(componentAPI, {\n        ...COMPONENT_LIFECYCLE_METHODS,\n        [PROPS_KEY]: {},\n        [STATE_KEY]: {},\n      }),\n      {\n        // defined during the component creation\n        [SLOTS_KEY]: null,\n        [ROOT_KEY]: null,\n        // these properties should not be overriden\n        ...COMPONENT_DOM_SELECTORS,\n        name,\n        css,\n        template,\n      },\n    ),\n  )\n}\n\nexport { instantiateComponent };\n","/* Riot v9.4.6, @license MIT */\nimport { IS_PURE_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { camelToDashCase } from '../dependencies/@riotjs/util/strings.js';\nimport { callOrAssign } from '../dependencies/@riotjs/util/functions.js';\nimport { memoize } from '../dependencies/@riotjs/util/misc.js';\nimport { MOCKED_TEMPLATE_INTERFACE } from './mocked-template-interface.js';\nimport { componentTemplateFactory } from './component-template-factory.js';\nimport { createPureComponent } from './create-pure-component.js';\nimport { instantiateComponent } from './instantiate-component.js';\n\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\nfunction createChildrenComponentsObject(components = {}) {\n  return Object.entries(callOrAssign(components)).reduce(\n    (acc, [key, value]) => {\n      acc[camelToDashCase(key)] = createComponentFromWrapper(value);\n      return acc\n    },\n    {},\n  )\n}\n\n/**\n * Create the getter function to render the child components\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Function} function returning the component factory function\n */\nconst createChildComponentGetter = (componentWrapper) => {\n  const childrenComponents = createChildrenComponentsObject(\n    componentWrapper.exports ? componentWrapper.exports.components : {},\n  );\n\n  return (name) => {\n    // improve support for recursive components\n    if (name === componentWrapper.name)\n      return memoizedCreateComponentFromWrapper(componentWrapper)\n    // return the registered components\n    return childrenComponents[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name)\n  }\n};\n\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\nconst memoizedCreateComponentFromWrapper = memoize(createComponentFromWrapper);\n\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\nfunction createComponentFromWrapper(componentWrapper) {\n  const { css, template, exports, name } = componentWrapper;\n  const templateFn = template\n    ? componentTemplateFactory(\n        template,\n        componentWrapper,\n        createChildComponentGetter(componentWrapper),\n      )\n    : MOCKED_TEMPLATE_INTERFACE;\n\n  return ({ slots, attributes, props }) => {\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL])\n      return createPureComponent(exports, {\n        slots,\n        attributes,\n        props,\n        css,\n        template,\n      })\n\n    const componentAPI = callOrAssign(exports) || {};\n\n    const component = instantiateComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name,\n    })({ slots, attributes, props });\n\n    // notice that for the components created via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope)\n      },\n      update(parentScope, state) {\n        return component.update(state, parentScope)\n      },\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot)\n      },\n    }\n  }\n}\n\nexport { createComponentFromWrapper };\n","/* Riot v9.4.6, @license MIT */\nimport { template as create } from '../dependencies/@riotjs/dom-bindings/dist/dom-bindings.js';\nimport expressionTypes from '../dependencies/@riotjs/util/expression-types.js';\nimport bindingTypes from '../dependencies/@riotjs/util/binding-types.js';\n\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {Function} getChildComponent - getter function to return the children components\n * @returns {TemplateChunk} template chunk object\n */\nfunction componentTemplateFactory(\n  template,\n  componentWrapper,\n  getChildComponent,\n) {\n  return template(\n    create,\n    expressionTypes,\n    bindingTypes,\n    getChildComponent,\n  )\n}\n\nexport { componentTemplateFactory };\n","/* Riot v9.4.6, @license MIT */\nimport { MOUNT_METHOD_KEY, IS_PURE_SYMBOL } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport { defineDefaults, defineProperty } from '../dependencies/@riotjs/util/objects.js';\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\n\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\nfunction createPureComponent(\n  pureFactoryFunction,\n  { slots, attributes, props, css, template },\n) {\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n\n  const component = defineDefaults(\n    pureFactoryFunction({ slots, attributes, props }),\n    PURE_COMPONENT_API,\n  );\n\n  return createCoreAPIMethods((method) => (...args) => {\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args;\n      // mark this node as pure element\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentInstance(element, component);\n    }\n\n    component[method](...args);\n\n    return component\n  })\n}\n\nexport { createPureComponent };\n","import { register } from 'riot'\n\nconst basename = (path, extension = '') => path.split('/').reverse()[0].replace(extension, '')\nconst globalComponentsContext = require.context('./components/global/', true, /[a-zA-Z0-9-]+\\.riot/)\n\nexport default () => {\n  globalComponentsContext.keys().map(path => {\n    const name = basename(path, '.riot')\n\n    const component = globalComponentsContext(path)\n\n    register(name, component.default || component)\n\n    return {\n      name,\n      component\n    }\n  })\n}\n","/* Riot v9.4.6, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\nfunction register(name, { css, template, exports }) {\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name))\n    panic(`The component \"${name}\" was already registered`);\n\n  COMPONENTS_IMPLEMENTATION_MAP.set(\n    name,\n    createComponentFromWrapper({ name, css, template, exports }),\n  );\n\n  return COMPONENTS_IMPLEMENTATION_MAP\n}\n\nexport { register };\n","/* Riot v9.4.6, @license MIT */\nimport $ from '../dependencies/bianco.query/index.next.js';\nimport { mountComponent } from '../core/mount-component.js';\n\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\nfunction mount(selector, initialProps, name) {\n  return $(selector).map((element) =>\n    mountComponent(element, initialProps, name),\n  )\n}\n\nexport { mount };\n","import './style.css'\nimport '@riotjs/hot-reload'\nimport { mount } from 'riot'\nimport registerGlobalComponents from './register-global-components'\n\n// register\nregisterGlobalComponents()\n\n// mount all the global components found in this page\nmount('[data-riot-component]')\n","/* Riot v9.4.6, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../dependencies/@riotjs/util/constants.js';\nimport { panic } from '../dependencies/@riotjs/util/misc.js';\nimport { getName } from '../utils/dom.js';\n\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @param   {Array} slots - component slots\n * @returns {Object} a new component instance bound to a DOM node\n */\nfunction mountComponent(element, initialProps, componentName, slots) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name))\n    panic(`The component named \"${name}\" was never registered`);\n\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps,\n    slots,\n  });\n\n  return component.mount(element)\n}\n\nexport { mountComponent };\n"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","DOMattributesToObject","element","Array","from","attributes","reduce","acc","attribute","name","value","moveChildren","source","target","firstChild","appendChild","cleanNode","node","removeChild","clearChildren","children","i","length","remove","insertBefore","newNode","refNode","parentNode","replaceChild","replaced","EACH","IF","SIMPLE","TAG","SLOT","bindingTypes","HEAD_SYMBOL","Symbol","TAIL_SYMBOL","UNMOUNT_SCOPE","EachBinding","nodes","mount","scope","parentScope","this","update","placeholder","childrenMap","collection","evaluate","items","newChildrenMap","batches","futureNodes","binding","condition","template","itemName","getKey","indexName","root","isTemplateTag","Map","forEach","item","index","context","extendScope","create","key","oldItem","get","mustFilterItem","mustMount","componentTemplate","clone","el","cloneNode","meta","fragment","dom","head","tail","document","createTextNode","createHeadTailPlaceholders","avoidDOMInjection","childNodes","createTemplateMeta","push","delete","set","createPatch","a","b","before","bLength","aEnd","bEnd","aStart","bStart","nextSibling","has","sequence","udomdiff","redundant","info","pop","unmount","patch","values","fn","IfBinding","mustUnmount","pristine","ElementProto","Element","prototype","isNativeHtmlProperty","hasOwnProperty","RE_EVENTS_PREFIX","EventListener","handleEvent","event","type","ListenersWeakMap","WeakMap","normalizeStringValue","getTextNode","childNodeIndex","expressions","attributeExpression","isBoolean","isBoolean$1","oldValue","newAttributes","oldAttributes","newKeys","filter","includes","removeAttribute","removeAllAttributes","setAllAttributes","shouldRemoveAttribute","canRenderAttribute","setAttribute","normalizeValue","normalizedEventName","replace","eventListener","listener","createListener","callback","options","isArray","getCallbackAndOptions","handler","mustAddEvent","removeEventListener","addEventListener","data","Expression","create$4","getRealParent","SlotBinding","getTemplateScope","attr","assign","extendParentScope","templateData","slots","find","realParent","html","bindings","createDOM","moveSlotInnerContent","mustRemoveRoot","slot","child","slotBindings","concat","TagBinding","tag","component","slotsToMarkup","getTag","getComponent","keepRootTag","expression","method","fixTextExpressionsOffset","textExpressionsOffset","create$1","templateTagOffset","selector","redundantAttribute","querySelector","bindingExpressions","TemplateChunk","container","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createSVGTree","createElement","innerHTML","content","createHTMLTree","createDOMTree","createTemplateDOM","createDocumentFragment","siblings","Math","max","indexOf","getTemplateTagOffset","injectDOM","bindingsData","normalizeUrl","srcByModuleId","noDocument","noop","updateCss","url","href","split","isUrlRequest","isLoaded","visited","newEl","Date","now","reloadAll","elements","querySelectorAll","call","test","moduleId","console","log","timeout","getScriptSrc","src","currentScript","scripts","getElementsByTagName","lastScriptTag","fileMap","splitResult","filename","mapRule","reg","RegExp","getCurrentScriptUrl","reloaded","loaded","ret","some","getReloadUrl","reloadStyle","locals","join","self","args","arguments","clearTimeout","setTimeout","apply","getName","tagName","toLowerCase","state","isPlaying","onMounted","player","$","onUpdated","playing","play","pause","getButtonTitle","toggleAudio","__","cssManager","DOMBindings","createBinding","createExpression","expressionTypes","globals","PROPS_KEY","STATE_KEY","IS_COMPONENT_UPDATING","ATTRIBUTES_KEY_SYMBOL","COMPONENTS_IMPLEMENTATION_MAP","PLUGINS_SET","DOM_COMPONENT_INSTANCE_PROPERTY","PARENT_KEY_SYMBOL","reload","componentAPI","els","toString","oldTag","newTag","implementation","props","fns","f","g","compose","c","warn","localsJsonString","cssReload","undefined","hot","invalidate","accept","dispose","ATTRIBUTE","EVENT","TEXT","VALUE","REF","normalize","attrs","prop","names","n","parseNodes","domToArray","panic","message","cause","memoize","cache","cached","val","evaluateAttributeExpressions","Set","IS_DIRECTIVE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","TEMPLATE_KEY_SYMBOL","checkType","isSvg","owner","ownerSVGElement","isTemplate","isFunction","isObject","isNil","constructor","defineProperty","enumerable","writable","configurable","defineProperties","properties","entries","defineDefaults","defaults","pick","fromEntries","CSS_BY_NAME","style","add","css","inject","camelToDashCase","string","dashToCamelCase","_","toUpperCase","urlString","trim","protocol","components","host","accumulator","callOrAssign","MOCKED_TEMPLATE_INTERFACE","PURE_COMPONENT_API","freeze","bindDOMNodeToComponentInstance","createCoreAPIMethods","mapFunction","COMPONENT_DOM_SELECTORS","$$","COMPONENT_LIFECYCLE_METHODS","curry","computeComponentState","oldState","newState","computeInitialProps","initialProps","getRootComputedAttributeNames","firstBinding","manageComponentLifecycle","runPlugins","createAttributeBindings","addCssHook","computedAttributeNames","staticRootAttributes","domNodeAttributes","newProps","preserveRoot","bind","instantiateComponent","createChildComponentGetter","componentWrapper","childrenComponents","createComponentFromWrapper","createChildrenComponentsObject","memoizedCreateComponentFromWrapper","templateFn","getChildComponent","componentTemplateFactory","pureFactoryFunction","createPureComponent","globalComponentsContext","path","extension","reverse","basename","register","default","mountComponent"],"sourceRoot":""}
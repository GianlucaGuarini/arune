{"version":3,"file":"app.bundle.js","mappings":"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","sources":["webpack://arune/./node_modules/@riotjs/hot-reload/index.js","webpack://arune/./src/components/global/player/player.riot","webpack://arune/./node_modules/bianco.query/index.next.js","webpack://arune/./node_modules/bianco.dom-to-array/index.next.js","webpack://arune/./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js","webpack://arune/./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js","webpack://arune/./src/style.css?e320","webpack://arune/./node_modules/riot/esm/api/mount.js","webpack://arune/./node_modules/riot/esm/core/mount-component.js","webpack://arune/./node_modules/riot/esm/api/register.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/functions.js","webpack://arune/./node_modules/riot/esm/core/pure-component-api.js","webpack://arune/./node_modules/riot/esm/core/mocked-template-interface.js","webpack://arune/./node_modules/riot/esm/core/bind-dom-node-to-component-instance.js","webpack://arune/./node_modules/riot/esm/core/create-core-api-methods.js","webpack://arune/./node_modules/riot/esm/core/component-dom-selectors.js","webpack://arune/./node_modules/riot/esm/core/component-lifecycle-methods.js","webpack://arune/./node_modules/riot/esm/node_modules/curri/index.next.js","webpack://arune/./node_modules/riot/esm/core/compute-component-state.js","webpack://arune/./node_modules/riot/esm/core/manage-component-lifecycle.js","webpack://arune/./node_modules/riot/esm/core/run-plugins.js","webpack://arune/./node_modules/riot/esm/core/create-attribute-bindings.js","webpack://arune/./node_modules/riot/esm/core/compute-initial-props.js","webpack://arune/./node_modules/riot/esm/core/add-css-hook.js","webpack://arune/./node_modules/riot/esm/core/instantiate-component.js","webpack://arune/./node_modules/riot/esm/core/create-component-from-wrapper.js","webpack://arune/./node_modules/riot/esm/core/component-template-factory.js","webpack://arune/./node_modules/riot/esm/core/create-pure-component.js","webpack://arune/./node_modules/riot/esm/core/css-manager.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/dom-bindings/dist/esm.dom-bindings.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/binding-types.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/checks.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/constants.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/dom.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/expression-types.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/misc.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/objects.js","webpack://arune/./node_modules/riot/esm/node_modules/@riotjs/util/strings.js","webpack://arune/./node_modules/riot/esm/node_modules/bianco.attr/index.next.js","webpack://arune/./node_modules/riot/esm/node_modules/bianco.dom-to-array/index.next.js","webpack://arune/./node_modules/riot/esm/node_modules/bianco.query/index.next.js","webpack://arune/./node_modules/riot/esm/api/unregister.js","webpack://arune/./node_modules/riot/esm/api/unmount.js","webpack://arune/./node_modules/riot/esm/api/install.js","webpack://arune/./node_modules/riot/esm/api/uninstall.js","webpack://arune/./node_modules/riot/esm/api/component.js","webpack://arune/./node_modules/riot/esm/node_modules/cumpa/index.next.js","webpack://arune/./node_modules/riot/esm/api/pure.js","webpack://arune/./node_modules/riot/esm/api/with-types.js","webpack://arune/./node_modules/riot/esm/api/version.js","webpack://arune/./node_modules/riot/esm/api/__.js","webpack://arune/./node_modules/riot/esm/utils/dom.js","webpack://arune/./src/components/global/ sync [a-zA-Z0-9-]+\\.riot","webpack://arune/./src/register-global-components.js","webpack://arune/./src/index.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('riot'), require('bianco.query')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'riot', 'bianco.query'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.riotHotReload = {}, global.riot, global.$));\n})(this, (function (exports, riot, $) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n\n  const { cssManager } = riot.__;\n  const { DOM_COMPONENT_INSTANCE_PROPERTY } = riot.__.globals;\n\n  function reload(componentAPI) {\n    const {name} = componentAPI;\n\n    if (!name) {\n      console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n      return []\n    }\n\n    return $__default[\"default\"](`${name}, [is=${name}]`).map(el => {\n      const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n      // early return in case there is no riot instance found\n      if (!oldTag) return\n\n      // remove the tag template from the DOM\n      oldTag.unmount(true);\n      // delete the old css from the css manager\n      cssManager.remove(name);\n\n      // create the new tag\n      const newTag = riot.component(componentAPI)(el, oldTag.props);\n      newTag.update(oldTag.state);\n\n      return newTag\n    })\n  }\n\n  exports[\"default\"] = reload;\n  exports.reload = reload;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","<player>\n  <audio src=\"/assets/audio/fx.mp3\" loop/>\n  <button class={state.isPlaying ? 'playing' : ''} onclick={toggleAudio} title={getButtonTitle()}>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 48 48\" preserveAspectRatio=\"xMidYMid meet\">\n      <path if={!state.isPlaying} d=\"M16 37.85v-28l22 14Zm3-14Zm0 8.55 13.45-8.55L19 15.3Z\"/>\n      <path if={state.isPlaying} d=\"M28.25 38V10H36v28ZM12 38V10h7.75v28Z\"/>\n    </svg>\n  </button>\n\n  <script>\n    export default {\n      state: {\n        isPlaying: false\n      },\n      onMounted() {\n        this.player = this.$('audio')\n      },\n      onUpdated() {\n        if (this.state.isPlaying && !this.player.playing) {\n          this.player.play()\n        } else if (!this.player.playing) {\n          this.player.pause()\n        }\n      },\n      getButtonTitle() {\n        return this.state.isPlaying ? 'Stop this madness' : 'Give me some vibes'\n      },\n      toggleAudio() {\n        this.update({\n          isPlaying: !this.state.isPlaying\n        })\n      }\n    }\n  </script>\n\n  <style>\n    :host {\n      position: fixed;\n      bottom: 16px;\n      right: 16px;\n    }\n\n    button {\n      position: relative;\n      padding: 0;\n      cursor: pointer;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      background: transparent;\n      color: var(--text-color);\n      border: 2px solid var(--text-color);\n      width: 32px;\n      height: 32px;\n      border-radius: 100%;\n    }\n\n    button:hover, button:focus {\n      color: var(--active-color);\n      border-color: var(--active-color);\n    }\n\n    button::before, button::after {\n      content: '';\n      position: absolute;\n      top: -2px;\n      left: -2px;\n      visibility: hidden;\n      display: block;\n      width: 32px;\n      height: 32px;\n      border-radius: 100%;\n      z-index: -1;\n    }\n\n    button::before {\n      background: rgba(255, 255, 255, 0.4);\n    }\n\n    button::after {\n      background: rgba(255, 255, 255, 0.2);\n    }\n\n    button.playing::before, button.playing::after {\n      visibility: visible;\n    }\n\n    button.playing::before {\n      animation: buttonAnimation1 ease-in-out 300ms alternate infinite;\n    }\n\n    button.playing::after {\n      animation: buttonAnimation2 ease-in-out 500ms alternate infinite;\n    }\n\n    svg {\n      width: 28px;\n      height: 28px;\n      border-radius: 100%;\n      background: var(--background-color);\n    }\n\n    @keyframes buttonAnimation1 {\n      from {\n        transform: scale(1)\n      }\n      to {\n        transform: scale(1.2)\n      }\n    }\n\n    @keyframes buttonAnimation2 {\n      from {\n        transform: scale(1)\n      }\n      to {\n        transform: scale(1.3)\n      }\n    }\n  </style>\n</player>\n","import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n","/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}","\"use strict\";\n\n/* eslint-env browser */\n\n/*\n  eslint-disable\n  no-console,\n  func-names\n*/\n\n/** @typedef {any} TODO */\nvar normalizeUrl = require(\"./normalize-url\");\n\nvar srcByModuleId = Object.create(null);\nvar noDocument = typeof document === \"undefined\";\nvar forEach = Array.prototype.forEach;\n/**\n * @param {function} fn\n * @param {number} time\n * @returns {(function(): void)|*}\n */\n\nfunction debounce(fn, time) {\n  var timeout = 0;\n  return function () {\n    // @ts-ignore\n    var self = this; // eslint-disable-next-line prefer-rest-params\n\n    var args = arguments;\n\n    var functionCall = function functionCall() {\n      return fn.apply(self, args);\n    };\n\n    clearTimeout(timeout); // @ts-ignore\n\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nfunction noop() {}\n/**\n * @param {TODO} moduleId\n * @returns {TODO}\n */\n\n\nfunction getCurrentScriptUrl(moduleId) {\n  var src = srcByModuleId[moduleId];\n\n  if (!src) {\n    if (document.currentScript) {\n      src =\n      /** @type {HTMLScriptElement} */\n      document.currentScript.src;\n    } else {\n      var scripts = document.getElementsByTagName(\"script\");\n      var lastScriptTag = scripts[scripts.length - 1];\n\n      if (lastScriptTag) {\n        src = lastScriptTag.src;\n      }\n    }\n\n    srcByModuleId[moduleId] = src;\n  }\n  /**\n   * @param {string} fileMap\n   * @returns {null | string[]}\n   */\n\n\n  return function (fileMap) {\n    if (!src) {\n      return null;\n    }\n\n    var splitResult = src.split(/([^\\\\/]+)\\.js$/);\n    var filename = splitResult && splitResult[1];\n\n    if (!filename) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    if (!fileMap) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    return fileMap.split(\",\").map(function (mapRule) {\n      var reg = new RegExp(\"\".concat(filename, \"\\\\.js$\"), \"g\");\n      return normalizeUrl(src.replace(reg, \"\".concat(mapRule.replace(/{fileName}/g, filename), \".css\")));\n    });\n  };\n}\n/**\n * @param {TODO} el\n * @param {string} [url]\n */\n\n\nfunction updateCss(el, url) {\n  if (!url) {\n    if (!el.href) {\n      return;\n    } // eslint-disable-next-line\n\n\n    url = el.href.split(\"?\")[0];\n  }\n\n  if (!isUrlRequest(\n  /** @type {string} */\n  url)) {\n    return;\n  }\n\n  if (el.isLoaded === false) {\n    // We seem to be about to replace a css link that hasn't loaded yet.\n    // We're probably changing the same file more than once.\n    return;\n  }\n\n  if (!url || !(url.indexOf(\".css\") > -1)) {\n    return;\n  } // eslint-disable-next-line no-param-reassign\n\n\n  el.visited = true;\n  var newEl = el.cloneNode();\n  newEl.isLoaded = false;\n  newEl.addEventListener(\"load\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.addEventListener(\"error\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.href = \"\".concat(url, \"?\").concat(Date.now());\n\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(newEl, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(newEl);\n  }\n}\n/**\n * @param {string} href\n * @param {TODO} src\n * @returns {TODO}\n */\n\n\nfunction getReloadUrl(href, src) {\n  var ret; // eslint-disable-next-line no-param-reassign\n\n  href = normalizeUrl(href);\n  src.some(\n  /**\n   * @param {string} url\n   */\n  // eslint-disable-next-line array-callback-return\n  function (url) {\n    if (href.indexOf(src) > -1) {\n      ret = url;\n    }\n  });\n  return ret;\n}\n/**\n * @param {string} [src]\n * @returns {boolean}\n */\n\n\nfunction reloadStyle(src) {\n  if (!src) {\n    return false;\n  }\n\n  var elements = document.querySelectorAll(\"link\");\n  var loaded = false;\n  forEach.call(elements, function (el) {\n    if (!el.href) {\n      return;\n    }\n\n    var url = getReloadUrl(el.href, src);\n\n    if (!isUrlRequest(url)) {\n      return;\n    }\n\n    if (el.visited === true) {\n      return;\n    }\n\n    if (url) {\n      updateCss(el, url);\n      loaded = true;\n    }\n  });\n  return loaded;\n}\n\nfunction reloadAll() {\n  var elements = document.querySelectorAll(\"link\");\n  forEach.call(elements, function (el) {\n    if (el.visited === true) {\n      return;\n    }\n\n    updateCss(el);\n  });\n}\n/**\n * @param {string} url\n * @returns {boolean}\n */\n\n\nfunction isUrlRequest(url) {\n  // An URL is not an request if\n  // It is not http or https\n  if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(url)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {TODO} moduleId\n * @param {TODO} options\n * @returns {TODO}\n */\n\n\nmodule.exports = function (moduleId, options) {\n  if (noDocument) {\n    console.log(\"no window.document found, will not HMR CSS\");\n    return noop;\n  }\n\n  var getScriptSrc = getCurrentScriptUrl(moduleId);\n\n  function update() {\n    var src = getScriptSrc(options.filename);\n    var reloaded = reloadStyle(src);\n\n    if (options.locals) {\n      console.log(\"[HMR] Detected local css modules. Reload all css\");\n      reloadAll();\n      return;\n    }\n\n    if (reloaded) {\n      console.log(\"[HMR] css reload %s\", src.join(\" \"));\n    } else {\n      console.log(\"[HMR] Reload all css\");\n      reloadAll();\n    }\n  }\n\n  return debounce(update, 50);\n};","\"use strict\";\n\n/* eslint-disable */\n\n/**\n * @param {string[]} pathComponents\n * @returns {string}\n */\nfunction normalizeUrl(pathComponents) {\n  return pathComponents.reduce(function (accumulator, item) {\n    switch (item) {\n      case \"..\":\n        accumulator.pop();\n        break;\n\n      case \".\":\n        break;\n\n      default:\n        accumulator.push(item);\n    }\n\n    return accumulator;\n  },\n  /** @type {string[]} */\n  []).join(\"/\");\n}\n/**\n * @param {string} urlString\n * @returns {string}\n */\n\n\nmodule.exports = function (urlString) {\n  urlString = urlString.trim();\n\n  if (/^data:/i.test(urlString)) {\n    return urlString;\n  }\n\n  var protocol = urlString.indexOf(\"//\") !== -1 ? urlString.split(\"//\")[0] + \"//\" : \"\";\n  var components = urlString.replace(new RegExp(protocol, \"i\"), \"\").split(\"/\");\n  var host = components[0].toLowerCase().replace(/\\.$/, \"\");\n  components[0] = \"\";\n  var path = normalizeUrl(components);\n  return protocol + host + path;\n};","// extracted by mini-css-extract-plugin\nexport {};\n    if(module.hot) {\n      // 1668114614349\n      var cssReload = require(\"../node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  ","/* Riot v7.1.0, @license MIT */\nimport $ from '../node_modules/bianco.query/index.next.js';\nimport { mountComponent } from '../core/mount-component.js';\n\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n\nexport { mount };\n","/* Riot v7.1.0, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\nimport { getName } from '../utils/dom.js';\n\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @param   {Array} slots - component slots\n * @returns {Object} a new component instance bound to a DOM node\n */\nfunction mountComponent(element, initialProps, componentName, slots) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps,\n    slots\n  });\n  return component.mount(element);\n}\n\nexport { mountComponent };\n","/* Riot v7.1.0, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponentFromWrapper({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n\nexport { register };\n","/* Riot WIP, @license MIT */\nimport { isFunction } from './checks.js';\n\n// does simply nothing\nfunction noop() {\n  return this;\n}\n\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\nexport { autobindMethods, callOrAssign, noop };\n","/* Riot v7.1.0, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '../node_modules/@riotjs/util/constants.js';\nimport { noop } from '../node_modules/@riotjs/util/functions.js';\n\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\n\nexport { PURE_COMPONENT_API };\n","/* Riot v7.1.0, @license MIT */\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { noop } from '../node_modules/@riotjs/util/functions.js';\n\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n\nexport { MOCKED_TEMPLATE_INTERFACE };\n","/* Riot v7.1.0, @license MIT */\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '../node_modules/@riotjs/util/constants.js';\n\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\nconst bindDOMNodeToComponentInstance = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;\n\nexport { bindDOMNodeToComponentInstance };\n","/* Riot v7.1.0, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '../node_modules/@riotjs/util/constants.js';\n\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n\nexport { createCoreAPIMethods };\n","/* Riot v7.1.0, @license MIT */\nimport $ from '../node_modules/bianco.query/index.next.js';\n\nconst COMPONENT_DOM_SELECTORS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n  $$(selector) {\n    return $(selector, this.root);\n  }\n});\n\nexport { COMPONENT_DOM_SELECTORS };\n","/* Riot v7.1.0, @license MIT */\nimport { SHOULD_UPDATE_KEY, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, ON_BEFORE_UPDATE_KEY, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY } from '../node_modules/@riotjs/util/constants.js';\nimport { noop } from '../node_modules/@riotjs/util/functions.js';\n\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\n\nexport { COMPONENT_LIFECYCLE_METHODS };\n","/* Riot WIP, @license MIT */\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\nexport { curry as default };\n","/* Riot v7.1.0, @license MIT */\nimport { callOrAssign } from '../node_modules/@riotjs/util/functions.js';\n\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state given to the `update` call\n * @returns {Object} new object state\n */\nfunction computeComponentState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n\nexport { computeComponentState };\n","/* Riot v7.1.0, @license MIT */\nimport { isFunction, isObject } from '../node_modules/@riotjs/util/checks.js';\nimport { PARENT_KEY_SYMBOL, ATTRIBUTES_KEY_SYMBOL, PROPS_KEY, STATE_KEY, TEMPLATE_KEY_SYMBOL, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, SHOULD_UPDATE_KEY, ON_BEFORE_UPDATE_KEY, IS_COMPONENT_UPDATING, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY, IS_PURE_SYMBOL, ROOT_KEY, SLOTS_KEY } from '../node_modules/@riotjs/util/constants.js';\nimport { autobindMethods } from '../node_modules/@riotjs/util/functions.js';\nimport { evaluateAttributeExpressions } from '../node_modules/@riotjs/util/misc.js';\nimport { defineProperties, defineProperty } from '../node_modules/@riotjs/util/objects.js';\nimport { addCssHook } from './add-css-hook.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { computeComponentState } from './compute-component-state.js';\nimport { computeInitialProps } from './compute-initial-props.js';\nimport { createAttributeBindings } from './create-attribute-bindings.js';\nimport { runPlugins } from './run-plugins.js';\n\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\nfunction manageComponentLifecycle(component, _ref) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, computeInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();\n\n      // link this object to the DOM node\n      bindDOMNodeToComponentInstance(element, this);\n      // add eventually the 'is' attribute\n      component.name && addCssHook(element, component.name);\n\n      // define the root element\n      defineProperty(this, ROOT_KEY, element);\n      // define the slots array\n      defineProperty(this, SLOTS_KEY, slots);\n\n      // before mount lifecycle event\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      // mount the template\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);\n\n      // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount();\n      // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n\nexport { manageComponentLifecycle };\n","/* Riot v7.1.0, @license MIT */\nimport { PLUGINS_SET } from '../node_modules/@riotjs/util/constants.js';\n\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n\nexport { runPlugins };\n","/* Riot v7.1.0, @license MIT */\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\nimport { createExpression as create$4 } from '../node_modules/@riotjs/dom-bindings/dist/esm.dom-bindings.js';\n\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n  const expressions = attributes.map(a => create$4(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n\nexport { createAttributeBindings };\n","/* Riot v7.1.0, @license MIT */\nimport { DOMattributesToObject } from '../node_modules/@riotjs/util/dom.js';\nimport { callOrAssign } from '../node_modules/@riotjs/util/functions.js';\n\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\nfunction computeInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n\nexport { computeInitialProps };\n","/* Riot v7.1.0, @license MIT */\nimport { IS_DIRECTIVE } from '../node_modules/@riotjs/util/constants.js';\nimport { getName } from '../utils/dom.js';\nimport { set } from '../node_modules/bianco.attr/index.next.js';\n\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n\nexport { addCssHook };\n","/* Riot v7.1.0, @license MIT */\nimport { SLOTS_KEY, ROOT_KEY, PROPS_KEY, STATE_KEY } from '../node_modules/@riotjs/util/constants.js';\nimport { defineProperties, defineDefaults } from '../node_modules/@riotjs/util/objects.js';\nimport { COMPONENT_DOM_SELECTORS } from './component-dom-selectors.js';\nimport { COMPONENT_LIFECYCLE_METHODS } from './component-lifecycle-methods.js';\nimport cssManager from './css-manager.js';\nimport curry from '../node_modules/curri/index.next.js';\nimport { manageComponentLifecycle } from './manage-component-lifecycle.js';\n\n/**\n * Component definition function\n * @param   {Object} implementation - the component implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\nfunction instantiateComponent(_ref) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(manageComponentLifecycle)(defineProperties(\n  // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_DOM_SELECTORS, {\n    name,\n    css,\n    template\n  })));\n}\n\nexport { instantiateComponent };\n","/* Riot v7.1.0, @license MIT */\nimport { IS_PURE_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP } from '../node_modules/@riotjs/util/constants.js';\nimport { camelToDashCase } from '../node_modules/@riotjs/util/strings.js';\nimport { callOrAssign } from '../node_modules/@riotjs/util/functions.js';\nimport { memoize } from '../node_modules/@riotjs/util/misc.js';\nimport { MOCKED_TEMPLATE_INTERFACE } from './mocked-template-interface.js';\nimport { componentTemplateFactory } from './component-template-factory.js';\nimport { createPureComponent } from './create-pure-component.js';\nimport { instantiateComponent } from './instantiate-component.js';\n\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\nfunction createChildrenComponentsObject(components) {\n  if (components === void 0) {\n    components = {};\n  }\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref) => {\n    let [key, value] = _ref;\n    acc[camelToDashCase(key)] = createComponentFromWrapper(value);\n    return acc;\n  }, {});\n}\n\n/**\n * Create the getter function to render the child components\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Function} function returning the component factory function\n */\nconst createChildComponentGetter = componentWrapper => {\n  const childrenComponents = createChildrenComponentsObject(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponentFromWrapper(componentWrapper);\n    // return the registered components\n    return childrenComponents[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  };\n};\n\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\nconst memoizedCreateComponentFromWrapper = memoize(createComponentFromWrapper);\n\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\nfunction createComponentFromWrapper(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper, createChildComponentGetter(componentWrapper)) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref2 => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = instantiateComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    });\n\n    // notice that for the components created via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n    };\n  };\n}\n\nexport { createComponentFromWrapper };\n","/* Riot v7.1.0, @license MIT */\nimport { template as create } from '../node_modules/@riotjs/dom-bindings/dist/esm.dom-bindings.js';\nimport expressionTypes from '../node_modules/@riotjs/util/expression-types.js';\nimport bindingTypes from '../node_modules/@riotjs/util/binding-types.js';\n\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {Function} getChildComponent - getter function to return the children components\n * @returns {TemplateChunk} template chunk object\n */\nfunction componentTemplateFactory(template, componentWrapper, getChildComponent) {\n  return template(create, expressionTypes, bindingTypes, getChildComponent);\n}\n\nexport { componentTemplateFactory };\n","/* Riot v7.1.0, @license MIT */\nimport { MOUNT_METHOD_KEY, IS_PURE_SYMBOL } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\nimport { defineDefaults, defineProperty } from '../node_modules/@riotjs/util/objects.js';\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\n\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args;\n      // mark this node as pure element\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentInstance(element, component);\n    }\n    component[method](...args);\n    return component;\n  });\n}\n\nexport { createPureComponent };\n","/* Riot v7.1.0, @license MIT */\nimport $ from '../node_modules/bianco.query/index.next.js';\nimport { set } from '../node_modules/bianco.attr/index.next.js';\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]';\n\n// memoized curried function\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style;\n\n    // create a new style element or use an existing one\n    // and cache it internally\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n\n    /* istanbul ignore next */\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nconst cssManager = {\n  CSS_BY_NAME,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n    return this;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n    return this;\n  }\n};\n\nexport { CSS_BY_NAME, STYLE_NODE_SELECTOR, cssManager as default };\n","/* Riot WIP, @license MIT */\nimport { removeChild, cleanNode, clearChildren, insertBefore, moveChildren, replaceChild } from '../../util/dom.js';\nimport { IS_PURE_SYMBOL, PARENT_KEY_SYMBOL } from '../../util/constants.js';\nimport { SIMPLE, IF, EACH, TAG, SLOT } from '../../util/binding-types.js';\nexport { default as bindingTypes } from '../../util/binding-types.js';\nimport { TEXT, EVENT, ATTRIBUTE, VALUE } from '../../util/expression-types.js';\nexport { default as expressionTypes } from '../../util/expression-types.js';\nimport { defineProperty } from '../../util/objects.js';\nimport { isTemplate, isSvg, isBoolean, isObject, isFunction, isNil } from '../../util/checks.js';\nimport { panic, memoize, evaluateAttributeExpressions } from '../../util/misc.js';\n\nconst HEAD_SYMBOL = Symbol();\nconst TAIL_SYMBOL = Symbol();\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n  return {\n    head,\n    tail\n  };\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {\n    head,\n    tail\n  } = createHeadTailPlaceholders();\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  };\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nconst udomdiff = (a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap )\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n\n    // prepare the diffing\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this);\n\n    // patch the DOM only if there are new nodes\n    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder);\n\n    // trigger the mounts and the updates\n    batches.forEach(fn => fn());\n\n    // update the children map\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n};\n\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {\n          template,\n          nodes,\n          context\n        } = element;\n        // remove the last node (notice <template> tags might have more children nodes)\n        nodes.pop();\n\n        // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n    return item;\n  };\n}\n\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false;\n}\n\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n  return scope;\n}\n\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    }\n\n    // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    }\n\n    // delete the old item from the children map\n    childrenMap.delete(key);\n    futureNodes.push(...nodes);\n\n    // update the children map\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\nfunction create$6(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n    this.value = value;\n    return this;\n  },\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n};\nfunction create$5(node, _ref3) {\n  let {\n    evaluate,\n    template\n  } = _ref3;\n  const placeholder = document.createTextNode('');\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach(_ref4 => {\n    let [name, value] = _ref4;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value);\n}\n\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0;\n}\n\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\nfunction attributeExpression(node, _ref5, value, oldValue) {\n  let {\n    name\n  } = _ref5;\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    }\n\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    }\n    return;\n  }\n\n  // handle boolean attributes\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return value === true ? name : value;\n}\nconst RE_EVENTS_PREFIX = /^on/;\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false];\n\n// see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n};\nconst ListenersWeakMap = new WeakMap();\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\nfunction eventExpression(node, _ref6, value) {\n  let {\n    name\n  } = _ref6;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n  return target;\n};\n\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\nconst expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n\n  // API methods\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope);\n\n    // IO() DOM updates\n    apply(this, this.value);\n    return this;\n  },\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n    return this;\n  },\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n};\n\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\nfunction create$4(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\nfunction create$3(node, _ref7) {\n  let {\n    expressions\n  } = _ref7;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));\n}\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n}\n\n// this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n  // template: null,\n\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(_ref8 => {\n      let {\n        id\n      } = _ref8;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n    }\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n    return this;\n  },\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n    return this;\n  },\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n    return this;\n  }\n};\n\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method \\_()_/\n */\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n  if (!child) return;\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\nfunction createSlot(node, _ref9) {\n  let {\n    name,\n    attributes\n  } = _ref9;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n  if (attributes === void 0) {\n    attributes = [];\n  }\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  }\n\n  // otherwise we return a template chunk\n  return create(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref10) => {\n    let {\n      bindings\n    } = _ref10;\n    return acc.concat(bindings);\n  }, []);\n}\n\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n\n  mount(scope) {\n    return this.update(scope);\n  },\n  update(scope, parentScope) {\n    const name = this.evaluate(scope);\n\n    // simple update\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true);\n\n      // mount the new tag\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n    return this;\n  },\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n    return this;\n  }\n};\nfunction create$2(node, _ref11) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref11;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\nconst bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\nfunction create$1(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding;\n  // find the node to apply the bindings\n  const node = selector ? root.querySelector(selector) : root;\n\n  // remove eventually additional attributes created only to select this node\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || [];\n\n  // init the binding\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\n// in this case a simple innerHTML is enough\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n}\n\n// for svg nodes we need a bit more work\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);\n}\n\n/**\n * Template Chunk model\n * @type {Object}\n */\nconst TemplateChunk = {\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n    return this;\n  },\n  // API methods\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n    if (!el) panic('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope);\n\n    // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta;\n    // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null;\n\n    // create the DOM if it wasn't created before\n    this.createDOM(el);\n\n    // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n    const cloneNode = fragment || this.dom.cloneNode(true);\n\n    // store root node\n    // notice that for template tags the root note will be the parent tag\n    this.el = isTemplateTag ? parentNode : el;\n\n    // create the children array only for the <template> fragments\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null;\n\n    // inject the DOM into the el only if a fragment is available\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode);\n\n    // create the bindings\n    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n\n    // store the template meta properties\n    this.meta = meta;\n    return this;\n  },\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (mustRemoveRoot === void 0) {\n      mustRemoveRoot = false;\n    }\n    const el = this.el;\n    if (!el) {\n      return this;\n    }\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break;\n\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break;\n\n      // clean the node children only\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break;\n\n      // remove the root node only if the mustRemoveRoot is truly\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break;\n    }\n    this.el = null;\n    return this;\n  },\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      meta: {},\n      el: null\n    });\n  }\n};\n\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\nfunction create(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\nexport { create$1 as createBinding, create$4 as createExpression, create as template };\n","/* Riot WIP, @license MIT */\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nconst bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nexport { EACH, IF, SIMPLE, SLOT, TAG, bindingTypes as default };\n","/* Riot WIP, @license MIT */\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template';\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object;\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nexport { checkType, isBoolean, isFunction, isNil, isObject, isSvg, isTemplate };\n","/* Riot WIP, @license MIT */\n// Riot.js constants that can be used across more modules\n\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nexport { ATTRIBUTES_KEY_SYMBOL, COMPONENTS_IMPLEMENTATION_MAP, DOM_COMPONENT_INSTANCE_PROPERTY, IS_COMPONENT_UPDATING, IS_DIRECTIVE, IS_PURE_SYMBOL, MOUNT_METHOD_KEY, ON_BEFORE_MOUNT_KEY, ON_BEFORE_UNMOUNT_KEY, ON_BEFORE_UPDATE_KEY, ON_MOUNTED_KEY, ON_UNMOUNTED_KEY, ON_UPDATED_KEY, PARENT_KEY_SYMBOL, PLUGINS_SET, PROPS_KEY, ROOT_KEY, SHOULD_UPDATE_KEY, SLOTS_KEY, STATE_KEY, TEMPLATE_KEY_SYMBOL, UNMOUNT_METHOD_KEY, UPDATE_METHOD_KEY };\n","/* Riot WIP, @license MIT */\nimport { dashToCamelCase } from './strings.js';\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \\_()_/\n */\n\n// Ignore this helper because it's needed only for svg tags\nfunction moveChildren(source, target) {\n  // eslint-disable-next-line fp/no-loops\n  while (source.firstChild) target.appendChild(source.firstChild);\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild);\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nfunction clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0; i < children.length; i++) removeChild(children[i]);\n}\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nconst removeChild = node => node.remove();\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nconst insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nconst replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);\n\nexport { DOMattributesToObject, cleanNode, clearChildren, insertBefore, moveChildren, removeChild, replaceChild };\n","/* Riot WIP, @license MIT */\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nconst expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\nexport { ATTRIBUTE, EVENT, TEXT, VALUE, expressionTypes as default };\n","/* Riot WIP, @license MIT */\nimport { VALUE, ATTRIBUTE } from './expression-types.js';\nimport { dashToCamelCase } from './strings.js';\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @param   { string } cause - optional error cause object\n * @returns { undefined } hoppla... at this point the program should stop working\n */\nfunction panic(message, cause) {\n  throw new Error(message, {\n    cause\n  });\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nfunction memoize(fn) {\n  const cache = new Map();\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n  cached.cache = cache;\n  return cached;\n}\n\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n    return acc;\n  }, {});\n}\n\nexport { evaluateAttributeExpressions, memoize, panic };\n","/* Riot WIP, @license MIT */\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the property overriding the default options\n * @returns {Object} the original object modified\n */\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(_ref => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\nexport { defineDefaults, defineProperties, defineProperty };\n","/* Riot WIP, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\nexport { camelToDashCase, dashToCamelCase };\n","/* Riot WIP, @license MIT */\nimport domToArray from '../bianco.dom-to-array/index.next.js';\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values;\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nexport { get, set };\n","/* Riot WIP, @license MIT */\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  }\n  // this object could be looped out of the box\n  return els;\n}\n\nexport { domToArray as default };\n","/* Riot WIP, @license MIT */\nimport domToArray from '../bianco.dom-to-array/index.next.js';\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nfunction $(selector, scope) {\n  return domToArray(typeof selector === 'string' ? (scope || document).querySelectorAll(selector) : selector);\n}\n\nexport { $ as default };\n","/* Riot v7.1.0, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\nimport cssManager from '../core/css-manager.js';\n\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n\nexport { unregister };\n","/* Riot v7.1.0, @license MIT */\nimport $ from '../node_modules/bianco.query/index.next.js';\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '../node_modules/@riotjs/util/constants.js';\n\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n    return element;\n  });\n}\n\nexport { unmount };\n","/* Riot v7.1.0, @license MIT */\nimport { isFunction } from '../node_modules/@riotjs/util/checks.js';\nimport { PLUGINS_SET } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\n\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n\nexport { install };\n","/* Riot v7.1.0, @license MIT */\nimport { PLUGINS_SET } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\n\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n\nexport { uninstall };\n","/* Riot v7.1.0, @license MIT */\nimport compose from '../node_modules/cumpa/index.next.js';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponentFromWrapper)(implementation);\n  };\n}\n\nexport { component };\n","/* Riot WIP, @license MIT */\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nexport { compose as default };\n","/* Riot v7.1.0, @license MIT */\nimport { isFunction } from '../node_modules/@riotjs/util/checks.js';\nimport { IS_PURE_SYMBOL } from '../node_modules/@riotjs/util/constants.js';\nimport { panic } from '../node_modules/@riotjs/util/misc.js';\n\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n\nexport { pure };\n","/* Riot v7.1.0, @license MIT */\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n/* istanbul ignore next */\nconst withTypes = component => component;\n\nexport { withTypes };\n","/* Riot v7.1.0, @license MIT */\n/** @type {string} current riot version */\nconst version = 'v7.1.0';\n\nexport { version };\n","/* Riot v7.1.0, @license MIT */\nimport bindingTypes from '../node_modules/@riotjs/util/binding-types.js';\nimport { DOM_COMPONENT_INSTANCE_PROPERTY, PARENT_KEY_SYMBOL } from '../node_modules/@riotjs/util/constants.js';\nimport expressionTypes from '../node_modules/@riotjs/util/expression-types.js';\nimport { template as create, createBinding as create$1, createExpression as create$4 } from '../node_modules/@riotjs/dom-bindings/dist/esm.dom-bindings.js';\nimport cssManager from '../core/css-manager.js';\n\n// expose some internal stuff that might be used from external tools\nconst __ = {\n  cssManager,\n  DOMBindings: {\n    template: create,\n    createBinding: create$1,\n    createExpression: create$4,\n    bindingTypes,\n    expressionTypes\n  },\n  globals: {\n    DOM_COMPONENT_INSTANCE_PROPERTY,\n    PARENT_KEY_SYMBOL\n  }\n};\n\nexport { __ };\n","/* Riot v7.1.0, @license MIT */\nimport { IS_DIRECTIVE } from '../node_modules/@riotjs/util/constants.js';\nimport { get } from '../node_modules/bianco.attr/index.next.js';\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nexport { getName };\n","var map = {\n\t\"./player/player.riot\": 666\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 329;","import { register } from 'riot'\n\nconst basename = (path, extension = '') => path.split('/').reverse()[0].replace(extension, '')\nconst globalComponentsContext = require.context('./components/global/', true, /[a-zA-Z0-9-]+\\.riot/)\n\nexport default () => {\n  globalComponentsContext.keys().map(path => {\n    const name = basename(path, '.riot')\n\n    const component = globalComponentsContext(path)\n\n    register(name, component.default || component)\n\n    return {\n      name,\n      component\n    }\n  })\n}\n","import './style.css'\nimport '@riotjs/hot-reload'\nimport { mount } from 'riot'\nimport registerGlobalComponents from './register-global-components'\n\n// register\nregisterGlobalComponents()\n\n// mount all the global components found in this page\nmount('[data-riot-component]')\n"],"names":["exports","riot","$","_interopDefaultLegacy","e","$__default","cssManager","__","DOM_COMPONENT_INSTANCE_PROPERTY","globals","reload","componentAPI","name","map","el","oldTag","unmount","remove","newTag","component","props","update","state","console","warn","Object","defineProperty","value","factory","isPlaying","onMounted","this","player","onUpdated","playing","play","pause","getButtonTitle","toggleAudio","selector","scope","els","document","querySelectorAll","Array","isArray","test","prototype","toString","call","length","from","normalizeUrl","srcByModuleId","create","noDocument","forEach","noop","updateCss","url","href","split","isUrlRequest","isLoaded","indexOf","visited","newEl","cloneNode","addEventListener","parentNode","removeChild","concat","Date","now","nextSibling","insertBefore","appendChild","reloadAll","elements","module","moduleId","options","log","fn","timeout","getScriptSrc","src","currentScript","scripts","getElementsByTagName","lastScriptTag","fileMap","splitResult","filename","mapRule","reg","RegExp","replace","getCurrentScriptUrl","reloaded","loaded","ret","some","getReloadUrl","reloadStyle","locals","join","self","args","arguments","functionCall","apply","clearTimeout","setTimeout","urlString","trim","protocol","components","host","toLowerCase","reduce","accumulator","item","pop","push","cssReload","id","hot","dispose","accept","undefined","mount","initialProps","element","componentName","slots","mountComponent","register","_ref","css","template","callOrAssign","source","constructor","PURE_COMPONENT_API","freeze","MOCKED_TEMPLATE_INTERFACE","assign","clone","createDOM","bindDOMNodeToComponentInstance","node","createCoreAPIMethods","mapFunction","acc","method","COMPONENT_DOM_SELECTORS","root","$$","COMPONENT_LIFECYCLE_METHODS","curry","_len","_key","_len2","_key2","computeComponentState","oldState","newState","manageComponentLifecycle","attributes","c","runPlugins","parentScope","expressions","a","binding","createAttributeBindings","computeInitialProps","addCssHook","newProps","preserveRoot","keys","filter","prop","bind","instantiateComponent","memoizedCreateComponentFromWrapper","createComponentFromWrapper","componentWrapper","templateFn","getChildComponent","componentTemplateFactory","childrenComponents","entries","key","createChildComponentGetter","_ref2","pureFactoryFunction","createPureComponent","CSS_BY_NAME","Map","style","add","has","set","inject","createElement","head","innerHTML","values","delete","HEAD_SYMBOL","Symbol","TAIL_SYMBOL","UNMOUNT_SCOPE","EachBinding","nodes","placeholder","childrenMap","collection","evaluate","items","newChildrenMap","batches","futureNodes","condition","itemName","getKey","indexName","isTemplateTag","index","context","extendScope","oldItem","get","mustFilterItem","mustMount","componentTemplate","meta","fragment","dom","tail","createTextNode","createHeadTailPlaceholders","avoidDOMInjection","children","childNodes","createTemplateMeta","createPatch","b","before","bLength","aEnd","bEnd","aStart","bStart","i","sequence","udomdiff","redundant","info","patch","IfBinding","mustUnmount","pristine","ElementProto","Element","isNativeHtmlProperty","hasOwnProperty","RE_EVENTS_PREFIX","EventListener","handleEvent","event","type","ListenersWeakMap","WeakMap","normalizeStringValue","getTextNode","childNodeIndex","target","nodeType","Node","COMMENT_NODE","textNode","replaceChild","attributeExpression","_ref5","oldValue","newAttributes","oldAttributes","newKeys","includes","attribute","removeAttribute","removeAllAttributes","_ref4","setAllAttributes","shouldRemoveAttribute","canRenderAttribute","setAttribute","normalizeValue","_ref6","normalizedEventName","eventListener","listener","createListener","callback","getCallbackAndOptions","handler","mustAddEvent","removeEventListener","data","expression","Expression","create$4","getRealParent","SlotBinding","getTemplateScope","attr","extendParentScope","templateData","find","_ref8","realParent","html","bindings","moveSlotInnerContent","mustRemoveRoot","slot","child","firstChild","slotBindings","_ref10","TagBinding","tag","getComponent","slotsToMarkup","keepRootTag","IF","_ref3","_ref7","_ref11","_ref9","fixTextExpressionsOffset","textExpressionsOffset","create$1","templateTagOffset","redundantAttribute","querySelector","bindingExpressions","TemplateChunk","container","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createSVGTree","content","createHTMLTree","createDOMTree","createTemplateDOM","createDocumentFragment","siblings","Math","max","getTemplateTagOffset","injectDOM","bindingsData","EACH","SIMPLE","TAG","SLOT","bindingTypes","checkType","isSvg","owner","ownerSVGElement","isTemplate","tagName","isFunction","isBoolean","isObject","isNil","COMPONENTS_IMPLEMENTATION_MAP","PLUGINS_SET","Set","IS_DIRECTIVE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","IS_COMPONENT_UPDATING","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","DOMattributesToObject","moveChildren","cleanNode","clearChildren","newNode","refNode","replaced","ATTRIBUTE","EVENT","TEXT","VALUE","expressionTypes","panic","message","cause","Error","memoize","cache","cached","val","evaluateAttributeExpressions","enumerable","writable","configurable","defineProperties","properties","defineDefaults","defaults","camelToDashCase","string","dashToCamelCase","_","toUpperCase","normalize","attrs","names","n","parseNodes","domToArray","unregister","keepRootElement","install","plugin","uninstall","implementation","_temp","fns","f","g","compose","pure","func","withTypes","version","DOMBindings","createBinding","createExpression","getName","webpackContext","req","webpackContextResolve","__webpack_require__","o","code","resolve","globalComponentsContext","path","extension","reverse","basename","default"],"sourceRoot":""}